{"version":3,"sources":["../node_modules/@supercharge/goodies/index.js","../node_modules/@supercharge/promise-pool/dist/index.js","../node_modules/@supercharge/promise-pool/dist/promise-pool.js","../node_modules/@supercharge/goodies/dist/index.js","../node_modules/@supercharge/goodies/dist/goodies.js","../node_modules/@supercharge/promise-pool/dist/promise-pool-executor.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/arrayLikeToArray.js","../node_modules/@supercharge/promise-pool/dist/promise-pool-error.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/isNativeFunction.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/construct.js"],"names":["module","exports","require","promise_pool_1","PromisePool","Object","defineProperty","value","goodies_1","promise_pool_executor_1","this","items","concurrency","errorHandler","undefined","tap","handler","callback","PromisePoolExecutor","withConcurrency","withHandler","handleError","for","start","ifNullish","isAsyncFunction","isPromise","upon","Goodies","promise","input","tapAsync","tapSync","isFunction","uponAsync","uponSync","then","constructor","name","predicate","promise_pool_error_1","tasks","errors","results","action","activeCount","length","validateInputs","process","Error","TypeError","Array","isArray","item","hasReachedConcurrencyLimit","processingSlot","startProcessing","drained","waitForTaskToFinish","Promise","race","task","createTaskFor","result","push","splice","indexOf","catch","error","PromisePoolError","createFrom","drainActiveTasks","all","unsupportedIterableToArray","o","Symbol","iterator","i","F","s","n","done","e","_e","f","it","err","normalCompletion","didErr","step","next","_e2","arrayLikeToArray","minLen","prototype","toString","call","slice","from","test","arr","len","arr2","message","messageFrom","captureStackTrace","getPrototypeOf","setPrototypeOf","isNativeFunction","construct","_wrapNativeSuper","Class","_cache","Map","has","get","set","Wrapper","arguments","create","enumerable","writable","configurable","fn","Function","isNativeReflectConstruct","_construct","Parent","args","Reflect","a","apply","instance","bind"],"mappings":"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","file":"static/js/67.e94ee89f.chunk.js","sourcesContent":["'use strict'\n\nmodule.exports = require('./dist')\n","'use strict';\nconst promise_pool_1 = require(\"./promise-pool\");\nmodule.exports = promise_pool_1.PromisePool;\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromisePool = void 0;\nconst goodies_1 = require(\"@supercharge/goodies\");\nconst promise_pool_executor_1 = require(\"./promise-pool-executor\");\nclass PromisePool {\n    /**\n     * Instantiates a new promise pool with a default `concurrency: 10` and `items: []`.\n     *\n     * @param {Object} options\n     */\n    constructor() {\n        this.items = [];\n        this.concurrency = 10;\n        this.errorHandler = undefined;\n    }\n    /**\n     * Set the number of tasks to process concurrently in the promise pool.\n     *\n     * @param {Integer} concurrency\n     *\n     * @returns {PromisePool}\n     */\n    withConcurrency(concurrency) {\n        return goodies_1.tap(this, () => {\n            this.concurrency = concurrency;\n        });\n    }\n    /**\n     * Set the number of tasks to process concurrently in the promise pool.\n     *\n     * @param {Number} concurrency\n     *\n     * @returns {PromisePool}\n     */\n    static withConcurrency(concurrency) {\n        return goodies_1.tap(this, () => {\n            this.concurrency = concurrency;\n        });\n    }\n    /**\n     * Set the items to be processed in the promise pool.\n     *\n     * @param {Array} items\n     *\n     * @returns {PromisePool}\n     */\n    for(items) {\n        return goodies_1.tap(this, () => {\n            this.items = items;\n        });\n    }\n    /**\n     * Set the items to be processed in the promise pool.\n     *\n     * @param {Array} items\n     *\n     * @returns {PromisePool}\n     */\n    static for(items) {\n        return new this()\n            .for(items)\n            .withConcurrency(this.concurrency);\n    }\n    /**\n     * Set the error handler function to execute when an error occurs.\n     *\n     * @param {Function} handler\n     *\n     * @returns {PromisePool}\n     */\n    handleError(handler) {\n        return goodies_1.tap(this, () => {\n            this.errorHandler = handler;\n        });\n    }\n    /**\n     * Starts processing the promise pool by iterating over the items\n     * and running each item through the async `callback` function.\n     *\n     * @param {Function} The async processing function receiving each item from the `items` array.\n     *\n     * @returns Promise<{ results, errors }>\n     */\n    async process(callback) {\n        return new promise_pool_executor_1.PromisePoolExecutor()\n            .withConcurrency(this.concurrency)\n            .withHandler(callback)\n            .handleError(this.errorHandler)\n            .for(this.items)\n            .start();\n    }\n}\nexports.PromisePool = PromisePool;\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ifNullish = exports.isAsyncFunction = exports.isPromise = exports.upon = exports.tap = void 0;\nconst goodies_1 = require(\"./goodies\");\nfunction tap(value, callback) {\n    return new goodies_1.Goodies().tap(value, callback);\n}\nexports.tap = tap;\nfunction upon(value, callback) {\n    return new goodies_1.Goodies().upon(value, callback);\n}\nexports.upon = upon;\n/**\n * Determine whether the given `promise` is a Promise.\n *\n * @param {*} promise\n *\n * @returns {Boolean}\n *\n * @example\n * isPromise('no') // false\n * isPromise(new Promise(() => {})) // true\n */\nfunction isPromise(promise) {\n    return new goodies_1.Goodies().isPromise(promise);\n}\nexports.isPromise = isPromise;\n/**\n * Determine whether the given `input` is an async function.\n *\n * @param {*} input\n *\n * @returns {Boolean}\n */\nfunction isAsyncFunction(input) {\n    return new goodies_1.Goodies().isAsyncFunction(input);\n}\nexports.isAsyncFunction = isAsyncFunction;\nfunction ifNullish(input, callback) {\n    return new goodies_1.Goodies().ifNullish(input, callback);\n}\nexports.ifNullish = ifNullish;\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Goodies = void 0;\nclass Goodies {\n    /**\n     * Handles the tap call and delegates it either to an async tap\n     * handler or to a sync tap handler.\n     *\n     * @param {*} value\n     * @param {Function} callback\n     *\n     * @returns {*} value\n     */\n    tap(value, callback) {\n        if (this.isPromise(value)) {\n            return this.tapAsync(value, callback);\n        }\n        if (this.isAsyncFunction(callback)) {\n            return this.tapAsync(value, callback);\n        }\n        return this.tapSync(value, callback);\n    }\n    /**\n     * Calls the given `callback` function with the\n     * given `value` and returns `value`.\n     *\n     * @param {*} value\n     * @param {Function} callback\n     *\n     * @returns {*} value\n     */\n    tapSync(value, callback) {\n        if (!callback) {\n            return value;\n        }\n        if (this.isFunction(callback)) {\n            callback(value);\n        }\n        return value;\n    }\n    /**\n    * Calls the given `callback` function with the given `value`\n    * and returns `value`. It resolves the `value` before\n    * passing it to the callback in case it is a Promise.\n     *\n     * @param {*} value\n     * @param {Function} callback\n     *\n     * @returns {*} value\n     */\n    async tapAsync(value, callback) {\n        if (!callback) {\n            return value;\n        }\n        if (this.isPromise(value)) {\n            value = await value;\n        }\n        if (this.isFunction(callback)) {\n            await callback(value);\n        }\n        return value;\n    }\n    /**\n     * Calls the given `callback` function with the given `value` and returns\n     * the result of the callback. It resolves the `value` before passing\n     * it to the callback in case it is a Promise.\n     *\n     * @param {*} value\n     * @param {Function} callback\n     *\n     * @returns {*} value\n     */\n    upon(value, callback) {\n        if (this.isPromise(value)) {\n            return this.uponAsync(value, callback);\n        }\n        if (this.isAsyncFunction(callback)) {\n            return this.uponAsync(value, callback);\n        }\n        return this.uponSync(value, callback);\n    }\n    /**\n     * Calls the given `callback` function with the given `value` and returns\n     * the result of the callback.\n     *\n     * @param {*} value\n     * @param {Function} callback\n     *\n     * @returns {*} value\n     */\n    uponSync(value, callback) {\n        if (!callback) {\n            return value;\n        }\n        return this.isFunction(callback)\n            ? callback(value)\n            : value;\n    }\n    /**\n     * Calls the given `callback` function with the given `value` and returns\n     * the result of the callback. It resolves the `value` before passing\n     * it to the callback in case it is a Promise.\n     *\n     * @param {*} value\n     * @param {Function} callback\n     *\n     * @returns {*} value\n     */\n    async uponAsync(value, callback) {\n        if (!callback) {\n            return value;\n        }\n        if (this.isPromise(value)) {\n            value = await value;\n        }\n        return this.isFunction(callback)\n            ? callback(value)\n            : value;\n    }\n    /**\n     * Determine whether the given `promise` is a Promise.\n     *\n     * @param {*} promise\n     *\n     * @returns {Boolean}\n     */\n    isPromise(promise) {\n        return !!promise && this.isFunction(promise.then);\n    }\n    /**\n     * Determine whether the given `input` is a function.\n     *\n     * @param {*} input\n     *\n     * @returns {Boolean}\n     */\n    isFunction(input) {\n        return typeof input === 'function';\n    }\n    /**\n     * Determine whether the given `func` is an async function.\n     *\n     * @param {*} input\n     *\n     * @returns {Boolean}\n     */\n    isAsyncFunction(input) {\n        return this.isFunction(input) && input.constructor.name === 'AsyncFunction';\n    }\n    /**\n     * Runs the given `callback` if the `predicate` is `null` or `undefined`.\n     *\n     * @param {Boolean} predicate\n     * @param {Function} callback\n     *\n     * @returns {*}\n     */\n    ifNullish(predicate, callback) {\n        if (predicate === null || predicate === undefined) {\n            return callback();\n        }\n    }\n}\nexports.Goodies = Goodies;\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromisePoolExecutor = void 0;\nconst goodies_1 = require(\"@supercharge/goodies\");\nconst promise_pool_error_1 = require(\"./promise-pool-error\");\nclass PromisePoolExecutor {\n    /**\n     * Creates a new promise pool executer instance with a default concurrency of 10.\n     */\n    constructor() {\n        this.tasks = [];\n        this.items = [];\n        this.errors = [];\n        this.results = [];\n        this.concurrency = 10;\n        this.handler = () => { };\n        this.errorHandler = undefined;\n    }\n    /**\n     * Set the number of tasks to process concurrently the promise pool.\n     *\n     * @param {Integer} concurrency\n     *\n     * @returns {PromisePoolExecutor}\n     */\n    withConcurrency(concurrency) {\n        return goodies_1.tap(this, () => {\n            this.concurrency = concurrency;\n        });\n    }\n    /**\n     * Set the items to be processed in the promise pool.\n     *\n     * @param {Array} items\n     *\n     * @returns {PromisePoolExecutor}\n     */\n    for(items) {\n        return goodies_1.tap(this, () => {\n            this.items = items;\n        });\n    }\n    /**\n     * Set the handler that is applied to each item.\n     *\n     * @param {Function} action\n     *\n     * @returns {PromisePoolExecutor}\n     */\n    withHandler(action) {\n        return goodies_1.tap(this, () => {\n            this.handler = action;\n        });\n    }\n    /**\n     * Set the error handler function to execute when an error occurs.\n     *\n     * @param {Function} handler\n     *\n     * @returns {PromisePoolExecutor}\n     */\n    handleError(handler) {\n        return goodies_1.tap(this, () => {\n            this.errorHandler = handler;\n        });\n    }\n    /**\n     * Determines whether the number of active tasks is greater or equal to the concurrency limit.\n     *\n     * @returns {Boolean}\n     */\n    hasReachedConcurrencyLimit() {\n        return this.activeCount() >= this.concurrency;\n    }\n    /**\n     * Returns the number of active tasks.\n     *\n     * @returns {Number}\n     */\n    activeCount() {\n        return this.tasks.length;\n    }\n    /**\n     * Start processing the promise pool.\n     *\n     * @returns {Array}\n     */\n    async start() {\n        return goodies_1.upon(this.validateInputs(), async () => {\n            return this.process();\n        });\n    }\n    /**\n     * Ensure valid inputs and throw otherwise.\n     *\n     * @throws\n     */\n    validateInputs() {\n        if (typeof this.handler !== 'function') {\n            throw new Error('The first parameter for the .process(fn) method must be a function');\n        }\n        if (!(typeof this.concurrency === 'number' && this.concurrency >= 1)) {\n            throw new TypeError(`\"concurrency\" must be a number, 1 or up. Received \"${this.concurrency}\" (${typeof this.concurrency})`);\n        }\n        if (!Array.isArray(this.items)) {\n            throw new TypeError(`\"items\" must be an array. Received ${typeof this.items}`);\n        }\n        if (this.errorHandler) {\n            if (typeof this.errorHandler !== 'function') {\n                throw new Error(`The error handler must be a function. Received ${typeof this.errorHandler}`);\n            }\n        }\n    }\n    /**\n     * Starts processing the promise pool by iterating over the items\n     * and running each item through the async `callback` function.\n     *\n     * @param {Function} callback\n     *\n     * @returns {Promise}\n     */\n    async process() {\n        for (const item of this.items) {\n            if (this.hasReachedConcurrencyLimit()) {\n                await this.processingSlot();\n            }\n            this.startProcessing(item);\n        }\n        return this.drained();\n    }\n    /**\n     * Creates a deferred promise and pushes the related callback to the pending\n     * queue. Returns the promise which is used to wait for the callback.\n     *\n     * @returns {Promise}\n     */\n    async processingSlot() {\n        return this.waitForTaskToFinish();\n    }\n    /**\n     * Wait for one of the active tasks to finish processing.\n     */\n    async waitForTaskToFinish() {\n        await Promise.race(this.tasks);\n    }\n    /**\n     * Create a processing function for the given `item`.\n     *\n     * @param {*} item\n     */\n    startProcessing(item) {\n        const task = this.createTaskFor(item)\n            .then(result => {\n            this.results.push(result);\n            this.tasks.splice(this.tasks.indexOf(task), 1);\n        })\n            .catch(error => {\n            this.tasks.splice(this.tasks.indexOf(task), 1);\n            if (this.errorHandler) {\n                return this.errorHandler(error, item);\n            }\n            this.errors.push(promise_pool_error_1.PromisePoolError.createFrom(error, item));\n        });\n        this.tasks.push(task);\n    }\n    /**\n     * Ensures a returned promise for the processing of the given `item`.\n     *\n     * @param item\n     *\n     * @returns {*}\n     */\n    async createTaskFor(item) {\n        return this.handler(item);\n    }\n    /**\n     * Wait for all active tasks to finish. Once all the tasks finished\n     * processing, returns an object containing the results and errors.\n     *\n     * @returns {Object}\n     */\n    async drained() {\n        await this.drainActiveTasks();\n        return {\n            results: this.results,\n            errors: this.errors\n        };\n    }\n    /**\n     * Wait for all of the active tasks to finish processing.\n     */\n    async drainActiveTasks() {\n        await Promise.all(this.tasks);\n    }\n}\nexports.PromisePoolExecutor = PromisePoolExecutor;\n","var unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nmodule.exports = _createForOfIteratorHelper;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromisePoolError = void 0;\nclass PromisePoolError extends Error {\n    /**\n     * Create a new instance for the given `message` and `item`.\n     *\n     * @param error  The original error\n     * @param item   The item causing the error\n     */\n    constructor(error, item) {\n        super();\n        this.item = item;\n        this.name = this.constructor.name;\n        this.message = this.messageFrom(error);\n        Error.captureStackTrace(this, this.constructor);\n    }\n    /**\n     * Returns a new promise pool error instance wrapping the `error` and `item`.\n     *\n     * @param {*} error\n     * @param {*} item\n     *\n     * @returns {PromisePoolError}\n     */\n    static createFrom(error, item) {\n        return new this(error, item);\n    }\n    /**\n     * Returns the error message from the given `error`.\n     *\n     * @param {*} error\n     *\n     * @returns {String}\n     */\n    messageFrom(error) {\n        if (error instanceof Error) {\n            return error.message;\n        }\n        if (typeof error === 'object') {\n            return error.message;\n        }\n        if (typeof error === 'string' || typeof error === 'number') {\n            return error.toString();\n        }\n        return '';\n    }\n}\nexports.PromisePoolError = PromisePoolError;\n","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nvar setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeFunction = require(\"./isNativeFunction\");\n\nvar construct = require(\"./construct\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper;","function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeReflectConstruct = require(\"./isNativeReflectConstruct\");\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;"],"sourceRoot":""}